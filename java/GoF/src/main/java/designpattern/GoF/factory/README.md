## 구현 방법
1. 모든 제품이 같은 인터페이스를 따르도록 하세요. 인터페이스는 모든 제품에서 의미가 있는 메서드들을 선언해야 합니다.
2. 크리에이터 클래스 내부에 빈 팩토리 메서드를 추가. 이 메서드의 반환 유형은 공통 제품 인터페이스와 일치해야 합니다.
3. 팩토리 메소드에 대한 호출로 교체하면서 제품 생성 코드를 팩토리 메서드로 추출
    반환된 제품의 유형을 제어하기 위해 팩토리 메서드에 임시 매개변수를 추가해야 할 수도 있습니다.
4. 팩토리 메서드에 나열된 각 제품 유형에 대한 크리에이터 자식 클래스들의 집합을 생성한 후, 자식 클래스들에서 팩토리 메서드를 오버라이딩하고 기초 메서드에서 생성자 코드의 적절한 부분들을 추출하세요.
5. 제품 유형이 너무 많아 모든 제품에 대하여 자식 클래스들을 만드는 것이 함리적이지 않을경우, 자식 클래스들의 기초 클래스의 제어 매개변수를 재사용할 수 있습니다.
6. 추출이 모두 끝난 후 기초 팩토리 메서드가 비어 있으면, 해당 팩토리 메서드를 추상화할 수 있습니다. 팩토리 메서드가 비어 있지 않으면, 나머지를 그 메서드의 디폴트 행동으로 만들 수 있습니다.

## 팩토리 메서드 장점
- 크리에이터와 구상 제품들이 단단하게 결합되지 않도록 할 수 있습니다.
- 단일 책임 원칙 제품 생성 코드를 프로그램의 한 위치로 이동하여 코드를 더 쉽게 유지 관리할 수 있습니다.
- 개방 폐쇄 원칙으로 기존 클라이언트 코드를 훼손하지 않고 새로운 유형의 제품들을 프로그램에 도입할 수 있습니다.

## 펙토리 메서드 단점
- 패턴을 구현하기 위해 많은 새로운 자식 클래스들을 도입해야 하므로 코드가 더 복잡해질 수 있습니다.

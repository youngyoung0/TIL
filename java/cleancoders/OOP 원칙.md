# OOP 원칙

### 왜 클린코드가 필요한가?

- SW는 한번 작성되면 최소 10번 이상 읽힌다.
그래서 대충 돌아만가게 작성하면 단되고 읽기 편하도록 작성
- 기계가 이해할 수 있는 코드는 어느 바보도 작성할 수 있다.
하지만 인간이 이해할 수 있는 코드는 잘 훈련된 포스트북이 엔지니어만이 작성할 수 있다.

### 절차지향 설계 vs 객체 지향 설계

절차지향 설계 

- SW = Data + Data를 조작하는 Code 알아야 할 것이 적어서 초기 진입이 쉽다.
- Data 변경이 많은 영향을 미침으로 변경이 어려워짐
모든 프로시저가 데이터를 공유

객체 지향 설계

- 데이터와 코드가 Encapsulated 데이터와 그 데이터를 조작하는 코드의 변경은 외부에 영향을 안 미침
- 외부에 노출된 인터페이스만 변경되지 않는다면 프로시저를 실행하는데 필요한 만큼의 데이터만 가짐

✔︎ 단순한 시스템은 쉬운 절차지향
✔︎ 복잡하거나 요구사항 변화가 발생할 시스템은 객체지향

✔︎ SW는 계속 사용된다면 요구사항은 계속 바뀐다.

✔︎ 절차지향이 처음엔 쉬울지 모르나 시간이 지나면 수정하기 어려운 구조가 된다.

---

### Object / Role / Responsibility

- 객체/클래스의 이름
- 역할은 관련된 책임의 집합
- 객체는 역할을 가짐

### 객체지향 설계 과정

기능을 제공할 객체 후보 선택

- 내부에서 필요한 데이터를 선별
- 클래스 다이어 그램
- 정적 설계

객체 간 메세지 흐름 연결

- 커뮤니케이션 다이어그램
- 시퀀스 다이어그램
- 동적 설계

기능을 제공할 객체 후보 선택과 객체 간 메세지 흐름 들을 반복

### Encapsulation(캡슐화)

1. 내부적으로 어떻게 구현했는지 감춰 내부의 변경(데이터, 코드)이 client가 변경되지 않도록
    - 코드 변경이 따른 비용 최소화
2. 절차지향
    - 요구사항이 변경이 데이터 구조 변경 유발
    - 데이터를 사용하는 모든 코드(Client, Test)의 수정 유발
3. 객체지향
    - 절차지향에 비해 확실히 작은 변경의 영향
    - 구현 변경의 유연함
    - 클라이언트에 영향 안 미침
4. Tell, Don’t Ask
    - 데이터를 요청해서 변경하고 저장하라고 하지말고 무슨 기능을 실행하라
    - 데이터를 잘 알고 있는 객체에게 기능을 수행하라고 하라
    - Encapsulation이 유지되어 변경에 영향을 안받게됨
    - if(member.getExpriedDate().getTime() < System.currentTimeMillis) → if(member.isExpired())
5. Law fo Demeber
    - 객체만 호출해야 한다.
    - 메소드에 전달된 모든 매개 변수
    - 모든 개체를 만들 수 있습니다.
    - 직접 보유되는 구성요소 개체.
6. Command vs Query
    - Command(Tell)
        - 객체의 내부 상태를 변경
        - 편이를 위해 어떤 결과를 반환할 수 있다.
    - Query (Ask)
        - 객체의 상태에 대한 정보를 제공
        - 객체의 상태를 변경하지 않는다.
        - free of side effects
    - 해당 객체의 외부에서 의사결정에 사용하지 않는다면 객체의 상태를 얻을 수 있다.
    - 해당 객체의 상태에 기반한 결정은 반드시 객체내에서 이뤄져야 한다.
    - Tell, Don’t Ask를 잘 지키게 해줌
    

### Polymorphism (다형성)

한 객체가 여러가지(poly) 모습/타입(morgh)을 가질 수 있다.

상속을 통해 다형성을 구현

- 구현 상속
    - 슈퍼 타입의 구현을 재사용
- 인터페이스 상속
    - 타입 정의와 상속
    - 상속은 객체에게 다형성을 제공

###
# 기본지식

# 자바

---

- 자바란?
    - JVM 가상머신 사용해서 운영체제와 독립적이다
    - Grabage collect 프로세스를 통해 자동으로 메모리 관리를 수행한다.
    - 멀티 스레드 지원
- 자바를 사용하는 이유
    - 객제 지향 언어 → 확장성, 유지 보수가 유리하다
    - 플랫폼과 독립적인 언어
    - 스레드를 지원해준다.
    - 높은 점유율
- JVM
    
    특징
    
    JVM은 플랫폼에 독립적이며,  자바 가상 머신 규격에 정의된 대로 자바 바이트 코드를 실행한다.
    
    CPU나 운영체제의 종류와 무관하게 동일하게 동작하는 것을 보장한다.
    
- 멀티 프로세스 vs 멀티 스레드
    
    멀티 프로세스
    
    - 같은 시간에 여러 개의 프로세스를 띄우고 실행하는 방식
    - 여러개의 프로세스를 동시에 수행하는것
    
    멀티 스레드
    
    - 같은 시간에 여러개의 스레드를 띄우고 실행하는 방식
    - 한 프로세스에서 여러 개의 스레드를 동시에 수행하는것
    
- call by value / call by reference
    
    call by value
    
    - 함수 호출시 전달되는 변수의 값을 복사하여 함수의 인자로 전달 하는 방식
    - 복사된 인자는 함수 안에서 지역적으로 사용된다.
    - 함수 안에서 인자의 값이 변경되어도, 호출때 매개변수로 사용된 외부의 값은 변경 되지 않는다.
    - Java 데이터 타입에 따라 함수 호출 방식
        - primitive type (원시 타입) : call by value로 동작 → int, short, long, float, double, char, boolean
        - reference type(참조 타입): 배열, 객체 인스턴스
    
    call by reference
    
    - 함수 호출시 인자로 전달되는 변수의 참조값을 전달하는 방식
    - 함수 안에서 인자의 값이 변경되면, 호출때 매개변수로 사용된 외부의 값도 함께 변경된다.
    
    Java는 call by value다
    
    - 객체의 주소 값을 직접 넘기지 않고, 객체 주소를 바라보는 또 다른 변수를 복사해 만들어서 넘긴다. → 인스턴스에 접근하는 참조 값을 저장하는 변수를 넘기는 것
- Generic을 사용하는 이유
    
    컴파일 타임때 런타임때 실행되는 타입의 안정성을 제공하기 위해 사용
    
    자바는 데이터 바인딩에 공변성의 특징을 가지기 때문에 버그 가능성이 있습니다. → 컴파일 타임에 런타임에 사용되는 타입을 검증을 하기 위함이다.
    
    - <Object>: Object만 받아 들인다.
    - <? extends Object>: Object를 상속받은 객체를 받아 들인다.
    
    제네릭을 사용하지 않을경우
    
    - List를 사용한다고 가정한다면, 매번 get할때마다 타입 캐스팅을 해주어야 한다. 이때 타입 캐스팅이 잘못되면 런타입시 ClassCastException이 발생하게 된다. (컴파일 타임때 발견하지 못한다는 것이 가장 큰 문제)
- Wrapper class
    
    Wrapper Class 사용하는 이유
    
    - Nullable
    - toString()를 통해 String 타입으로 바로 변환 가능
    - 원시타입을 객체 타입처럼 사용가능(자율적인 객체로 사용 가능)
    - Generic 타입으로 사용하기 위함
- Generic은 왜 Wrapper Class만 사용가능한가?
    - Generic 사용하는 이유 타입 체크를 위함. → 컴파일 타임시에만 타입 체크 및 제약을 적용하고, 자동 형변환을 해준다.  .class 파일에는 실제로 제네릭 정보가 전혀 없다.(소거됨)
    - 런타임엔 Generic으로 주어진 타입으로 형변환된 Object만이 존재할 수 있다. 그러기 때문에 Primitive 타입은 Object가 될 수 없기에 불가능한것.
- 생성자 vs 정적 팩토리 메서드
    
    정적 팩토리 메서드 장점
    
    - 이름을 가질수 있다.
    - 반드시 새로운 객체를 만들 필요가 없다. 불변 객체를 캐싱하거나, Validation을 처리할 수 있다.
    - 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    - static 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
    
    정적 팩토리 메서드의 단점
    
    - 상속하려면 public, protected 생성자가 필요하다, 정적 팩토리 메서드만 제공하면 하위 클래스 만들수 없다.
    - static 팩토리 메서드는 프로그래머가 찾기 어렵다.
- String 객체는 객체인데 왜 new로 선언하지 않는다?
    
    String은 불변객체로 **String 상수 풀영역 에서 객체를 관리**한다 → 상수처럼 이미 선언된 String 객체가 있으면 이 영역에서 가져다 사용하고, 없다면 여기에 새롭게 객체를 생성하여 사용한다.
    
- 불변 객체를 써야하는 이유
    
    불변 객체란
    
    - 생성후 그 상태를 변경할 수 없는 객체
    - 외부에서 불변 객체의 값을 수정할 수 없는 객체
    - 대표적인 예 → String, Boolean, Integer / 대표적인 가변 객체 → StringBuilder
    
    불변 객체를 왜 사용하는가?
    
    - 멀티 스레드 환경에서 안전하다. 동기화를 고려하지 않아도 된다.
    - 부수효과가 발생할 확률이 적다.
        - 객체는 기본적으로 참조 값을 통해 접근하기 때문에, 방어적 복사를 통해 불변으로 만들어 두는 것이 좋다.
        - 여러 스레드나 메서드에서 Money를 사용하게 된다면 언제 어디서 부수효과가 발생해 내부 값이 변경 될지 모르기 때문에 안전하지 않다.
    - 캐시나 Map또는 Set의 요소를 활용하기에 적합하다.
    
    컬렉션을 불변으로 만들려면 요소도 불변으로 만들어줘야된다.
    
    - List를 불변으로 해도, 그 요소가 불변이 아니면 언제든 가변이 될 수 있기 때문이다.
    
    단점으로는 메모리 낭비를 유발할 수 있다.
    
    - Garbage Collect커스텀을 통해 개선할 수 있다.
- 불변 만드는 방법
    
    원시 타입에서의 불변
    
    - 원시 타입은 값을 그대로 외부로 내보내도 불변임을 보장한다.
    - setter를 통해서는 객체 내부에서의 원시 타입을 불변을 막을수 없다.
    - setter를 생성하지 않고, finla을 붙여줘 생성자만을 통해서 설정되도록하면 불변을 보장할 수 있다. 혹은 특정 메시지를 통해서만 원시 타입이 변경되도록 하면된다.
    
    참조 타입에서의 불변
    
    - 객체는 기본적으로 참조 값을 통해 접근하기에, 불변성을 보장하기 어렵다
    - final + 방어적 복사를 통해 참조 타입을 불변으로 만들 수 있다.
    - 컬렉션을 불변으로 만들기 위해서는, 해당 컬렉션의 요소도 불변으로 만들어줘야한다.
- 자바에서 null을 안전하게 다루는 방법은?
    
    null의 정의
    
    - null은 값이 할당되지 않은 변수
    - 모든 참조 유형이 될 수 있는 특수 리터럴
    
    null의 문제점
    
    - null은 쉽게 Null Point Exception를 발생시킬 수 있다.
    - null을 반환할 수 있는 메서드는 클라이언트로 하여금 혼란을 초래할 수 있다.
        - 클라이언트 입장에서 null이 반환되는 메서드인지 아닌지 항상 확인해줘야 한다.
    
    null을 안전하게 다루는 방법
    
    - Assertion(단정문) 사용
    - Objects 사용 (isNull, nonNull, requireNonNull,…)
    - Optional
    
    추천하는 null 방지 도구
    
    - Optional
    - JSR305
    - JSR308(@NonNull, @Nullable)
- Optional 사용시 주의할 점
    
    Optional은 최대 1개 원소를 가지는 특별한 Stream이다.
    
    isPresent()를 사용하지 않는다. → orElse, orElseGet등을 사용
    
    - isPresent()를 호출하여 null인지 확인하고 다른 로직을 가져가는 경우 이 경우 굳이 Optional로 감쌀 필요가 없다.
    - 차라리 그냥 null인지 확인하는 로직을 넣는 것이 더 좋다. 대신 orElse, orElseGet 등등 사용하자.
    
    orElse(new …) 대신 orElseGet(() → new …)를 사용하자
    
    - orElse(new …)는 무조건 실행된다. 만약 새로운 객체를 생성하거나 새로운 연산을 수행하는 경우에는 orElseGet(() → new …)를 사용하자 이는 Optional에 값이 없을때만 실행된다.
    - Optional은 필드로 사용하면 안된다. 반환 값으로만 사용하자
    - Optional은 비싸다. 비어있는 컬렉션은 반환할 때는 Optional을 감싸지 말고, 빈 컬렉션을 반환
- java의 non-static와 static의 차이
    - non-static은 특정 객체의 대한 상태(동적 변수 혹은 인스턴스 변수)를 의미하고, static은 여러 객체가 공유하는 상태(정적 변수 혹은 클래스 변수)를 의미한다.
    - non-static은 객체가 생성되고 할당되며, 해당 객체의 상태를 나타내며, static은 객체가 생성되지 않아도 할당되며, 모든 객체에서 사용 가능하다.
    - non-static 메서드에서는 static 변수와 메서드에 모두 접근 가능하지만, static 메서드에서는 non-static 변수와 메서드에 접근하지 못한다 → 아직 생성되지 않았기 때문에)
    - 생명주기가 다르다. non-static은 인스턴스와 생명주기를 같이하며, static은 프로그램과 생명주기를 같이한다.
    - 쉽게 얘기하면, non-static은 인스턴스(객체)에 속하고, static은 클래스 자체에 속한다.
- Enum을 사용하는 이유
    
    Enum이란?
    
    - 서로 연관된 상수들의 집합
    - 클래스를 이용한 상수
        - 각각의 상수들은 모두 인스턴스화된 싱글톤 객체 이다.
        - 각각의 상수들은 서로 다른 데이터를 의미한다.
        - 같은 집합의 상수들은 같은 데이터 타입을 가지므로 서로 다른 집합의 상수끼리 비교 연산은 컴파일 시에 막을 수 있다.
    - 사용하는 이유
        - 상수를 객체처럼 사용할수 있다.
        - 서로 연관된 상수들끼리 집합으로 묶고, 서로 다른 집합의 상수끼리 비교 연산을 컴파일 타임에 막을 수 있기때문
- 오버로딩과 오버라이딩의 차이
    
    오버로딩 : 재구성
    
    - 한 클래스 내에 같은 이름의 메서드를 여러개 정의한느것 단, 기존 메서드와 매개변수의 개수 또는 타입이 달라야 한다.
    - 새로운 메서드를 정의하는것
    
    오버라이딩 : 재정의
    
    - 인터페이스 혹은 상위 클래스의 메서드를 재정의
    - 기존 메서드를 재정의하는것
- Stream이란? 장점과 특징
    
    Stream이란?
    
    - Stream은 선언형 방식으로 컬렉션 데이터를 조작하는 API
        - 선언형 방식 : 내부 반복 → Stream을 이용한 내부 반복
        - 명령형 방식 : 외부 반복 → 기존의 반복문을 통한 외부 반복
    - 스트림은 ‘데이터의 흐름’이다. 배열 또는 컬렉션에 함수 여러개를 조합해서 원하는 결과를 필터링하고 가공된 결과를 얻을 수 있다.
        - DB의 쿼리와 같이 정형화된 처리 패턴을 적용 시킨것
        - 배열 혹은 컬렉션의 데이터를 쿼리(Stream와 동일하다고 봐도 무방) 하는것
- Stream에서 map과 flatmap의 차이는?
    - map은 단일 스트림 안에 요소를 원하는 특정 형태로 변환시켜주는 중간 연산 메서드
    - flatmap은 스트림의 형태(요소)가 배열이나 리스트일때 각 리스트의 모든 원소를 특정 형태로 변환하고 단일 원소 스트림으로 반환시켜주는 중간 연산 메서드
- 함수형 프로그래밍 개념과 특징
    
    함수형 프로그래밍
    
    - 함수를 값으로 바라보고 명령형이 아닌 선언형으로 프로그래밍하는 프로그래밍 방식을 말한다.
    
    명령형과 선언형
    
    - 명령형 프로그래밍
        - What보다는 How을 나타냄
        - 클래스에서 메서드를 정의하고, 필요할때 그 메서드를 호출하는 명령하여 동작
    - 선언형 프로그래밍
        - How보다는 What을 설명
        - 데이터가 입력으로 주어지고, 데이터가 처리되는 과정(흐름)을 정의하는 것으로 동작
    
    함수형 프로그래밍의 조건
    
    - 순수 함수
        - 부수효과가 없으며, 같은 입력이 주어지면 항상 같은 결과를 반환한다.
        - 멀티 스레드로부터 안전하다.
    - 고차 함수
        - 일급 함수의 특징을 만족해야한다.
        - 함수의 인자로 함수를 전달할 수 있다.
        - 함수의 리턴값으로 함수를 사용할 수 있다.
    - 익명 함수
        - 이름이 없는 함수. 자바에서의 익명 클래스 혹은 람다식
    - 합성 합수
        - 새로운 함수를 생성하거나 어떤 계산을 수행하기 위해 둘 이상의 함수를 결합하는 것이다.
        - 메서드 체이니
    
    함수형 프로그래밍의 특징
    
    - 불변성
        - 상태를 변경하지 않는것
        - 상태를 변경하게 되면, 부수효과가 생기게 되어 순수 함수의 조건을 만족하지 못한다.
    - 참조 투명성(순수 함수)
        - 프로그램 동작의 변경없이 관련 값을 대처할 수 있다면 표현식을 참조 상 투명하다고 한다.
        - 즉, 참조상 투명한 함수는 같은 입력이 주어지면 항상 같은 결과를 반환한다.
    - 일급 함수
        - 함수를 함수의 매개변수, 반환값, 자료구조로 사용할 수 있다.
    - 게으른 평가
        - 함수형 언어에서는 값이 필요한 시점에 평가된다.
    
    함수형 프로그래밍의 장점
    
    - 동시성에서 발생할 수 있는 부수효과를 없앨 수 있다.
    - 멅티 스레딩 환경에서 스레드 세이프를 보장하면서 안정적으로 병렬처리를 할 수 있다.
    - 높은 수준의 추상화를 지원한다. 개발자는 How 보다는 What에 집중할수 있다. (핵심 가치에 집중 가능)
    - 함수 단위의 코드 재사용이 수월하다.
    - 불변이기에 코드를 예측하기 쉽다.
- Lambda식이란?
    
    Lambda식이란
    
    - 람다식은 메서드를 하나의 ‘식'으로 표현한 것이다.
    - 메서드로 전달할 수 있는 익명 클래스 메서드를 단순화 한것
    - 한수형 인터페이스를 이용하여 람다식을 구현한다.
    
    Lambda는 함수형 프로그래밍의 특징은 모두 가지고 있다고 보면 된다.
    
    - 일급 객체의 역할을 수행할 수 있으며, 메서드의 매개변수로 전달될 수도 있다. 또한, 변수에 담거나, 메서드의 결과값으로 반환될 수도 있다.
    
    장점
    
    - 불필요한 코드를 줄여주고, 가독성을 높여준다,
    - 익명 클래스와는 다르게 클래스를 생성하지 않는다.
- 익명 클래스 vs 람다식
    
    둘의 차이점은 바이트 코드를 보면 쉽게 파악할 수 있다.
    
    익명 내부 클래스는 새로운 클래스를 생성하지만, 람다는 새로운 메서드를 생성하여 포함한다.
    
    - 익명 내부 클래스
        - `static` 중첩 클래스를 생성한다.
    - 람다식
        - 람다식은 `static`이든, 객체를 사용을 위한 `non-static`이든 클래스를 따로 생성하지 않고, 메서드를 생성한다.
    - `this`
        - 익명 내부 클래스의 `this` : 새로 생성된 클래스
            - 새로운 클래스를 만들기 때문에, 익명 내부 클래스에서의 `this`는 익명 클래스 자신을 가리킨다.
        - 람다식의 `this` : 람다식이 선언된 (포함하고 있는) 클래스
            - 람다식은 새로운 메서드로 볼 수 있으며, 메서드에서 `this`는 메서드를 가진 클래스를 의미한다.
            - 람다식에서는 `this`는 람다를 포함하고 클래스의 인스턴스이다.
    - 메서드의 개수
        - 익명 내부 클래스는 여러개의 메서드를 가질 수 있다.
        - 람다식은 `@FunctionalInterface`를 사용하므로, 하나 이상의 메서드를 가지면 컴파일 에러가 발생한다.
    - 람다도 일종의 클로저다
        - 클로저 : 함수 범위 밖의 자유변수를 참조할 수 있는 함수
        - 람다가 람다식 범위 밖에 변수에 접근하고자 한다면, 해당 변수는 `final`이어야 한다.
- == 과 equals()의 차이점은?
    
    == : 동일성
    
    - == 은 primitive면 값 비교, reference이면 주소 비교를 통해 boolean 값을 리턴한다.
    
    equlas() : 동등성
    
    - equals()는 Object 클래스에 정의된 메서드이며, 객체의 값을 비교하여 boolean 값을 리턴한다.
    - equals()와 hashCode()를 재정의함으로써 동등성을 구현한다.
    
    hashCode() : 재정의하지 않는다면
    
    - HashMap과 HashTable에서 key에 대한 중복 여부를 equals()와 hashCode()로 하기 때문에, 둘 다 재정의해줘야 한다.
    - hashCode()를 재정의할 땐, 해당 객체의 상태를 통해 해시값을 계산해야 한다.
- Checked Exception vs Unchecked Exception
    
    다른점
    
    - 컴파일때 예외처리 여부
    
    Checked Exception
    
    - 프로그래머가 별도의 예외처러를 하지 않으면 컴파일 단계에서 오류를 발생시키는 예외
    - 비관적인 예외처리 기법이라 불린다.
    - SQLException, IOException
    
    UncheckedException
    
    - 프로그래머가 별도의 예외처리를 하지 않아도 컴파일 단계에서 오류를 발생시키지 않는 예외
    - 낙관적인 예외처리 기법이라 불린다.
    - Null Point Exception, RuntimeException
- Checked Exception을 지양하는 이유는?
    
    자칫 잘못하면 한 메서드를 사용하는 모든 메서드가 무책임하게 throws로 예외를 던지는 문제가 발생한다.
    
    OCP(개방 폐쇄의 원칙)를 위반하게 도리수도 있다.→ 결합도가 높아진다.
    
    - 특정 클래스에 의존하는 다른 클래스들로 예외 시그니처가 전달되고, 그로 인해 발생하는 결합도가 유지보드성에 악영향을 끼친다.
    - 또한, 모든 상위 메서드들이 최하위 메서드의 예외 시그니처를 알아야 하므로 캡슐화가 깨진다.
    
    예외를 throw 한 메서드와 depth가 3만 멀어져도 이 예외의 발생 근원지를 추측하기가 어려워진다.
    
    - 어디서 진짜 예외가 발생했는지 찾기가 힘들다는 것
    
    물론 반대 의견도 있다. 바로 엘리강트 오브젝트
    
    - 각 클래스, 메서드의 시그니처가 아주 명확해야 한다는 의견이다.
    - 즉, 예외 가능성이 있는 메서드가 Unchecked Exception을 사용하는 것은 클라이언트를 속인다는것!
    - 하지만, 개인적으로 Unchecked를 사용하고, 문서화를 하는것이 좋아보인다.
    
    Checked Exception 지양한 예시
    
    - SQLException → DataAccessException
- 업캐스팅과 다운 캐스팅
    
    캐스팅 == 형변환
    
    업캐스팅
    
    - 하위 클래스의 객체가 상위 클래스 타입으로 형변환 되는것
    - 상위 클래스 타입의 참조 변수로 하위 클래스의 인스턴스를 참조하면 묵시적으로 업캐스팅이 발생한다.
    - 하위클래스의 멤버에는 접근 불가하다.
    
    다운 캐스팅
    
    - 자신의 고유한 특성을 잃은 하위 클래스의 객체를 다시 복구시켜주는 것을 의미한다.
    - 업캐스팅된 것을 다시 원상태로 돌리는 것
    - 업캐스팅이 선행되어야 하며, 명시적으로 타입을 지정해줘야 한다.
    
- 정적 바인딩 vs 동적 바인딩
    
    바인딩
    
    - 프로그램 구성 요소의 성격을 결정해주는 것
    - ex. 변수의 데이터 타입이 무엇인지 정해지는것.
    
    정적 바인딩
    
    - 컴파일타임에 성격이 결정된다.
        - 변수의 경우 정적 할당(c, c++, java). 컴파일 타임에 타입이 결정됨
        - 메서드의 경우, 호출되는 메서드가 컴파일 타임에 결정된다.
    
    동적 바인딩
    
    - 다형성을 사용하여 메서드를 호출할 때, 발생하는 현상
    - 런타임에 성격이 결정된다.
- Collection vs Collections
    
    Collection
    
    - 컬렉션 프레임워크의 루트 인터페이스
    - List, Set, Queue등을 모두 Collection 인터페이스를 상속한다.
    - map 인터페이스는 단순히 값을 배열로 저장하는 List, Set과 다르게 키: 값으로 저장하기 때문에, Collection 인터페이스를 상속 받지 않는다. → 그저 컬렉션 프레임워크에 같이 정의만 되어있다.
    
    Collections
    
    - 컬렉션을 대상으로 하는 정렬, 검색, 최소, 최대값검색 등을 지원하는 유틸성 객체이다.
- Inner Class 와 Nested Class
    
    자바에서는 class 안에 class 선언할 수 있다.
    
    - 논리적으로 군집화를 할수 있으며, 불필요한 외부 노출을 줄여 캡슐화를 할 수 있다. 가독성을 높이며 유지 보수하기 좋은 코드를 작성할 수 있다.
    
    종류
    
    - static Nested Class
    - Inner Class
        - Local Inner Class
        - Anonymous Clas
    
    Static Nested Class vs Inner Class
    
    - 둘의 차이점은 static으로의 선언 여부이다. Inner Class는 static을 붙이지 않는 경우
    - 멤버 접근
        - Static Nested Class는 Outer Class의 static 멤버를 제외한 어떠한 멤버도 접근할 수 없다.
        - Inner class는 Outer Class의 모든 멤버에 접근 가능하다.
    - 객체 생성
        - Static Nested Class는 Outer Class와 관계없이 독립적으로 객체를 생성가능
        - Inner Class는 Outer Class의 객체를 생성한 뒤 해당 객체를 이용해서 객체를 생성할 수 있다.
            - Inner Class의 경우 보통 Outer Class에 대한 참조를 갖고 있다. 이로인해 GC가 수거 하지 못해, 메모리 누수 가능성이 있다.
    
    Nested Class를 구현하는데 Outer Class에 대한 멤버를 참조하지 않는다면, 무조건 Static Nested Class로 선언해주는 것이 좋다.
    
- 접근 제어자
    
    클래스나 멤버 선언시 부가적인 의미를 부여하는 키워드
    
    객체 지향의 정보은닉을 위해 사용된다.
    
    종류
    
    - public : 외부에 전체 공개되며, 어디에서나 접근할수 있다.
    - protected : 같은 패키지 혹은 다른 패키지에서 해당 클래스를 상속한 클래스에서 접근 가능하다.
    - default : 클래스 멤버는 같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근가능하다.
    - private : 같은 클래스 내에서만 접근 가능하며, 외부에서 접근이 불가능하다.
- 직렬화 / 역직렬화 차이
    
    직렬화 : 데이터를 연속적인 데이터로 변형하는것
    
    - 객체 → 스트림 (전송 혹은 저장하기 위함)
    
    역직렬화: 직렬화된 데이터를 변환하여 객체의 형태로 표현하는것
    
    - 스트림 → 객체(전송 혹은 저장된 것을 다시 객체로 사용하기 위함)
- 깊은 복사와 얕은 복사
    
    얕은 복사 : 객체의 저장된 멤버들을 그대로 복사한다.
    
    - 객체안에 저장된 멤버중 참조하고 있는 객체는 복제 되지 않는다.
    - 참조변수만 복제되고, 힘에 저장되어 있는 객체는 그대로 남아 있는다.
    - 원본을 변경하면 복사본도 영향을 받는다. (힙에 저장된 객체는 그대로 이다)
    
    깊은 복사 : 객체의 저장된 멤버들의 참조하고 있는 객체까지 복제 한다.
    
    - 객체안에 저장된 멤버중 참조하고 있는 객체까지 복제한다.
    - 참조변수도 복제하고, 힙에 저장되어 있는 객체까지 복제한다.( new를 통해 인스턴스화)
    - 원본의 변경이 복사본의 영향을 끼치지 못한다.(힙에 저장된 객체가 서로 다르기 때문)

# Spring

---

- 스프링이란?
    - 스프링은 자바 엔터프라이즈 개발을 위한 오픈소스 애플리케이션 프레임워크
    - 자바를 이용한 동적 웹 사이트를 개발하기 위해 여러가지 추상화 서비스를 제공하는 애플리케이션 프레임워크
    - 핵심 요소
        - 애플리케이션 개발시 오직 애플리케이션 레벨의 비즈니스 로직에만 집중할 수 있도록 다양한 서비스 인프라 지원한다.
- 프레임워크와 라이브러리 차이
    
    제어
    
    - 라이브러링(능동)
        - 라이브러리를 사용하는 코드는 애플리케이션 흐름을 직접 제어한다.
        - 개발자가 라이브러리 코드를 호출하여 전체적인 코드의 흐름을 주도한다.
    - 프레임워크(수동)
        - 프레임워크는 거꾸로 코드가 프레임워크에 의해 사용된다.
        - 개발자는 프레임워크 흐름중 핵심 부분만 작성하고 프레임 워크가 전체적인 흐름을 주도한다.
    
    목적
    
    - 둘 다 목적은 코드의 재사용성과 편의성
    - 라이브러리는 재사용성에 더 집중하고, 프레임워크는 기본적인틀을 제공해주는것에 집중한다.
- 스프링을 사용하는 이유
    
    방대한 문서
    
    - 자바 진영에서 가장 보편화된 프레임 워크, 문서화가 잘 되어 있다.
    
    개발 편의성, 생산성
    
    - 비즈니스 로직에만 집중할 수 있도록 다양한 애플케이션 레벨에서의 인프라를 갖추고 있따. 개발자는 비즈니스 로직에만 집중하면 된다.
    
    비침투성 - POJO(관심사 분리) - 객체지향적 특징
    
    - 비침투성을 지향하기 때문에, 기존의 도메인 부분에 대한 자바 코드를 최대한 건드리지 않고 웹 서비스를 할 수 있다.
    
    엔터프라이즈 프레임 워크  - 대용량 트래픽을처리 검증됨
    
    - 스프링은 검증된 다양한 기능들과 오픈소스 생태계를 지원한다.
    - Spring batch나 Spring security등과 같이 다양한 하위 프로젝트을 제공한다.
    
    성능향상 - 싱글톤 레지스트리
    
    - 일반적인 자바 싱글톤의 장점 - 서버 관점
        - 매 요청마다 새로운 객체를 생성해 로직을 수행하면 비용이 너무 높다. (객체를 싱글톤으로 관리하는 것이 성능상 유리)
    - 일반적인 자바 싱글톤의 문제
        - private 생성자를 갖고 있기에 상속할 수 없다.
        - 테스트하기 힘들다
        - 전역 상태로 만들기 때문에 바람직하지 않다.
        - 객체지향적으로 사용하기 때문에 (의존성)
    - 스프링은 기존 싱글톤의 장점을 모두 취하고, 단점을 모두 배제한 싱글톤 형식의 객체를 사용할 수 있도록 지원한다.
        - 평범한 자바 클래스를 싱글톤으로 활용하게해준다.
        - 가장 중요한 점은 기존 싱글톤 패턴과 달리 스프링이 제공하는 싱글톤은 객체지향적 설계방식과 디자인 패턴등을 적용하는데 아무런 제약이 없다는 것이다.
    
    테스트
    
    - DI를 통한 테스트 객체를 쉽게 주입해줌으로써 테스트를 쉽게 진행할 수 이싸.
    - 통합 테스트르 제공해준다.

- 스프링 핵심 원칙
    
    스프링의 핵심 원칙은 IoC/DI, AOP, PSA
    
    IoC
    
    - Inversion Of Control(제어의 역전)을 의미하며, 객체 생성과 생명주기 관리까지 모든 객체에 대한 제어권을 개발자가 아닌 프레임워크에게 위임한 것을 의미한다.
    - IoC vs DI : loC는 DI의 한 형태 → 객체지향에선 DI를 통해 IoC를 구현한다.
    
    DI
    
    - 의존관계 주입을 의미한다. 의존관계란 하나의 객체가 다른 객체의 상태에 따라 영향을 받는 것을 의미한다.
    - 스프링에서는 이러한 의존관계 개발자가 직접 관리하지 않고, 스프링 컨테이너에서 관리한다. 의존관꼐가 필요할때마다 스프링 컨테이너에서 개발자 코드안으로 의존성을 주입해준다.
    - DI는 스프링에서 IoC를 구현한 한가지 방법이며, IoC는 DI를 포함하는 개념이다
    - 객체생성, 생명주기 관리, 의존관계 설정 책임을 신경쓸 필요없이 자신의 비즈니스 로직에만 집중하여 생산성을 높일수 있다.
    
    AOP
    
    - Aspect-Oriented Programming(관점 지향 프로그래밍)
    - 스프링 DI가 의존성에 대한 주입이라면 AOP는 로직(code) 주입이라고 할 수 있다.
    - 관점 지향은 쉽게 말해 어떤 로직을 핵심적인 관점과 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다.
        - 핵심적인 관점 : 비즈니스 로직
        - 부가적인 관점 : 핵심 로직을 실행하기 위해서 행해지는 로직(로깅, 트랜잭션, 캐싱) - 재사용한다.
    
    PSA
    
    - Portable Service Abstraction(일관성 있는 서비스 추상화)
    - 서비스 추상화란, 같은 일을 하는 다수의 기술을 공통의 인터페이스로 제어할 수 있게 하는 것을 의미한다.
    - 외부 환경의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 해주는것을 의미한다.
        - @Cacheable : 캐시대상으로 redis를 사용하던 ehcache를 사용하던 @Cacheable을 처리하는 내부 코드는 변하지  않는다.
        - @Transactional : JPA의 구현체로 hibernate를 이용하던 다른 구현체를 이용하던 @Transactional을 처리하는 내부 코드를 변경할 필요가 없다.
- Spring과 Spring Boot
    
    자동 설정
    
    - Spring의 경우 Dispatcher Servlet을 직접 서블릿 컨테이너에 등록해줘야 하며, IoC 컨테이너도 직접 실행해주어야 한다. 이외에도 다양한 (JDBC, JPA 등등)을 수동으로 설정해주어야 한다.
    - Spring boot는 @EnableAutoConfiguration을 통해 spring-boot-autoconfigure/META-INF/spring.factories에 명시된 다양한 설정들을 의존성에 따라 빈을 등록해준다. (의존성이 존쟁할 때만 자동등록)
    - Dispatcher Servlet와 IoC 컨테이너와 같은 설정도 자동으로 해준다.
    
    쉬운 의존성 관리
    
    - Spring Boot의 경우 의존성만 주입해주면 Spring Boot가 알아서 설정하여 사용할 수 있게 해준다.
    
    내장 톰켓
    
    - Spring의 경우 직접 톰캣을 시동해주어야 한다.
    - Spring Boot의 경우 내장 톰캣을 이용하여 자바 코드를 실행하여 웹 서비스를 할 수 있다.
- POJO
    
    진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기줄에 종속되지 않고 필요에 따라 재활용 될 수 있는 방식을 설계된 오브젝트를 말한다.
    
    - 어떠한 프레임워크에도 의존하지 않는다
    - 자바를 이용한 테스트에 용이하다
    
    POJO의 두가지 의견
    
    - 어떠한 프레임워크에도 완전히 의존하지 않는 자바 객체(애노테이션이 붙은 것도 POJO가 아니라 의견)
    - 자바 객체 안에 코드를 프레임워크를 바꿔도 그대로 재활용할 수 있으면 POJO(특정 애노테이션이 존재해도 POJO라는 의견)
    
    번외
    
    - EJB 시절에는 특정 기능(Service, Controller 등)을 만들기 위해서는 특정 인터페이스나 클래스는 extends 했어야 했다. 따라서 그 시절에는 특정 클래스는 EJB 프레임워크에 매우 의존적이었으며 기능을 활용하기 위해서 특정 Class를 extends해야한다는 관점에서 객체지향적 특징을 잃어버리게 되었다(이미 상속을 사용하였으므로 상속의 특징을 활용하지 못함). 이것에 반발하여 EJB에 종속적이지 않은 클래스들을 POJO라고 정의하게 되었다.
    - EJB 때는 걔네들이 정의해둔 클래스/인터페이스를 상속/구현 → **그래서 이거에 종속적이지 않는 것들은 POJO라고 부르자고 정한 것.**
    - 결론적으로 비즈니스 코드가 특정 프레임워크에만 종속적이지 않는다면 POJO라고 부른다. (애노테이션은 주석과 같이 마킹한다는 의미에서 코드에 직접적으로 영향을 주지 않으므로 제외시킨다.)
    
    예시 
    
    - @Service와 같은 애노테이션들이 붙은 클래스들도 POJO가 맞다.
    - 그이유는 애노테이션 기반 프레임워크를 사용할 때, 애노테이션만 변경하고 코드 레벨에서 변경은 발생하지 않기 때문이다.
    
    예외
    
    - @Entity는 특정 제약사항이 필요하기 때문에 (빈 생성자, id 등등..) POJO가 아니아
- 생성자 주입을 추천하는 이유
    
    불변
    
    - 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경하지 않는것이 좋다.
    - 그 이유는 불변을 보장함으로써, 추후에 발생할 수 있을 버그를 사전에 차단해 주는 효과를 얻기때문이다.
    
    생성자 주입은 Setter의 단점을 모두 커버한다.
    
    - 객체를 만들때 의존성을 주입해주지 않아도 생성이 된다 → Null Point Exception발생 확률 존재
    - Setter 주입의 경우 상태가 불변하지 않기 때문에 실수할 확률이 높다.
    
    스프링에 의존적이지 않다.
    
    - 스프링 application context가 없어도 단독으로 테스트 혹은 도메인으로써의 역할을 수행할 수 있다.
- 필드 주입을 추천하지 않는 이유
    
    스프링에 의존적인 코드가 된다. - 스프링은 기본적으로 비침투성(POJO)를 지향한다.
    
    - 우선 필드 주입은 수정자(Setter) 주입과 유사한 방식으로 동작한다.
    - 또한, 필드 주입은 IoC 컨테이너에서 제공해주는 것이므로 컨테이너에 너무 의존적인 코드가 된다.
    - 만약 테스트시 application context가 없다면 해당 객체는 테스트가 불가능 하다. (순수 자바 코드 단위 테스트 불가)
- servlet과 servlet container
    
    servlet
    
    - Java로 HTTP 요청 및 응답을 처리하기 위한 표준
    - 서블릿은 클라이언트의 http요청을 받아 비즈니스 로직을 수행하고, 적절한 http응답을 생성하는 자바 객체이다.
    - 웹페이지를 동적으로 생성하는 역할
    - 서블릿은 일반 자바 객체와 달리 서블릿 컨테이너 내에서만 실행된다.
    
    servlet container (tomact, netty)
    
    - 클라이언트로부터 http요청 메시지를 적절하게 파싱 후, 스레드를 생성하여 적절한 서블릿을 실행시키고, 서블릿으로 부터 응답받은 요청 처리 결과를 이용해 http 응답 메시지를 만드러주는 컴포넌트
    - 웹서비스에 필요한 다양한 기능을 제공하며, 비즈니스 로직만 집중할 수 있도록 도와주는 프레임워크
    - 지원하는 기능
        - tcp/ip 소켓 연결 및 종료(통신 지원)
        - http 요청 메시지 파싱 및 응답 메시지 생성
        - 서블릿 생명주기 관리 ( 서블릿의 탄생과 죽을을 관리)
        - 멀티스레딩 지원 (요청당 스레드로 처리)
        - 선언적인 보안관리
- servlet container의 동작 흐름
    1. 사용자 요청 파싱
    2. 새로운 스레드를 생성하고, HttpServletRequest, HttpServletResponse생성
    3. 사용자 요청을 분석하여 대응되는 서블릿 검색. (DD.xml을 통해 서블릿을 미리 정의해 둔다.)
    4. 찾은 서블릿의 service() 메서드 호출함으로써, 비즈니스 로직 처리 위임.
    5. 서블릿은 클라이언트에게 넘길 응답을 작성. 이때 Response 객체를 사용한다.
    6. servlet container가 서블릿으로부터 받은 Response를 적절한 http response로 만들어 클라이언트에 반환
    7. 요청에 처리한 스레드는 소멸하거나 스레드 풀로 반환
# 자바

- 자바란?
    - JVM 가상머신 사용해서 운영체제와 독립적이다
    - Grabage collect 프로세스를 통해 자동으로 메모리 관리를 수행한다.
    - 멀티 스레드 지원
- 자바를 사용하는 이유
    - 객제 지향 언어 → 확장성, 유지 보수가 유리하다
    - 플랫폼과 독립적인 언어
    - 스레드를 지원해준다.
    - 높은 점유율
- JVM
    
    특징
    
    JVM은 플랫폼에 독립적이며,  자바 가상 머신 규격에 정의된 대로 자바 바이트 코드를 실행한다.
    
    CPU나 운영체제의 종류와 무관하게 동일하게 동작하는 것을 보장한다.
    
- 멀티 프로세스 vs 멀티 스레드
    
    멀티 프로세스
    
    - 같은 시간에 여러 개의 프로세스를 띄우고 실행하는 방식
    - 여러개의 프로세스를 동시에 수행하는것
    
    멀티 스레드
    
    - 같은 시간에 여러개의 스레드를 띄우고 실행하는 방식
    - 한 프로세스에서 여러 개의 스레드를 동시에 수행하는것
    
- call by value / call by reference
    
    call by value
    
    - 함수 호출시 전달되는 변수의 값을 복사하여 함수의 인자로 전달 하는 방식
    - 복사된 인자는 함수 안에서 지역적으로 사용된다.
    - 함수 안에서 인자의 값이 변경되어도, 호출때 매개변ㅅ로 사용된 외부의 값은 변경 되지 않는다.
    - Java 데이터 타입에 따라 함수 호출 방식
        - primitive type (원시 타입) : call by value로 동작 → int, short, long, float, double, char, boolean
        - reference type(참조 타입): 배열, 객체 인스턴스
    
    call by reference
    
    - 함수 호출시 인자로 전달되는 변수의 참조값을 전달하는 방식
    - 함수 안에서 인자의 값이 변경되면, 호출때 매개변수로 사용된 외부의 값도 함께 변경된다.
    
    Java는 call by value다
    
    - 객체의 주소 값을 직접 넘기지 않고, 객체 주소를 바라보는 또 다른 변수를 복사해 만들어서 넘긴다. → 인스턴스에 접근하는 참조 값을 저장하는 변수를 넘기는 것
- Generic을 사용하는 이유
    
    컴파일 타임때 런타임때 실행되는 타입의 안정성을 제공하기 위해 사용
    
    자바는 데이터 바인딩에 공변성의 특징을 가지기 때문에 버그 가능성이 있습니다. → 컴파일 타임에 런타임에 사용되는 타입을 검증을 하기 위함이다.
    
    - <Object>: Object만 받아 들인다.
    - <? extends Object>: Object를 상속받은 객체를 받아 들인다.
    
    제네릭을 사용하지 않을경우
    
    - List를 사용한다고 가정한다면, 매번 get할때마다 타입 캐스팅을 해주어야 한다. 이때 타입 캐스팅이 잘못되면 런타입시 ClassCastException이 발생하게 된다. (컴파일 타임때 발견하지 못한다는 것이 가장 큰 문제)
- Wrapper class
    
    Wrapper Class 사용하는 이유
    
    - Nullable
    - toString()를 통해 String 타입으로 바로 변환 가능
    - 원시타입을 객체 타입처럼 사용가능(자율적인 객체로 사용 가능)
    - Generic 타입으로 사용하기 위함
    
- Generic은 왜 Wrapper Class만 사용가능한가?
    - Generic 사용하는 이유 타입 체크를 위함. → 컴파일 타임시에만 타입 체크 및 제약을 적용하고, 자동 형변환을 해준다.  .class 파일에는 실제로 제네릭 정보가 전혀 없다.(소거됨)
    - 런타임엔 Generic으로 주어진 타입으로 형변환된 Object만이 존재할 수 있다. 그러기 때문에 Primitive 타입은 Object가 될 수 없기에 불가능한것.
- 생성자 vs 정적 팩토리 메서드
    
    정적 팩토리 메서드 장점
    
    - 이름을 가질수 있다.
    - 반드시 새로운 객체를 만들 필요가 없다. 불변 객체를 캐싱하거나, Validation을 처리할 수 있다.
    - 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    - static 패토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
    
    정적 팩토리 메서드의 단점
    
    - 상속하려면 public, protected 생성자가 필요하다, 정적 팩토리 메서드만 제공하면 하위 클래스 만들수 없다.
    - static 팩토리 메서드는 프로그래머가 찾기 어렵다.
- String 객체는 객체인데 왜 new로 선언하지 않는다?
    
    String은 불변객체로 **String 상수 풀영역 에서 객체를 관리**한다 → 상수처럼 이미 선언된 String 객체가 있으면 이 영역에서 가져다 사용하고, 없다면 여기에 새롭게 객체를 생성하여 사용한다.
    
- 불변 객체를 써야하는 이유
    
    불변 객체란
    
    - 생성후 그 상태를 변경할 수 없는 객체
    - 외부에서 불변 객체의 값을 수정할 수 없는 객체
    - 대표적인 예 → String, Boolean, Integer / 대표적인 가변 객체 → StringBuilder
    
    불변 객체를 왜 사용하는가?
    
    - 멀티 스레드 환경에서 안전하다. 동기화를 고려하지 않아도 된다.
    - 부수효과가 발생할 확률이 적다.
        - 객체는 기본적으로 참조 값을 통해 접근하기 때문에, 방어적 복사를 통해 불변으로 만들어 두는 것이 좋다.
        - 여러 스레드나 메서드에서 Money를 사용하게 된다면 언제 어디서 부수효과가 발생해 내부 값이 변경 될지 모르기 때문에 안전하지 않다.
    - 캐시나 Map또는 Set의 요소를 활용하기에 적합하다.
    
    컬렉션을 불변으로 만들려면 요소도 불변으로 만들어줘야된다.
    
    - List를 불변으로 해도, 그 요소가 불변이 아니면 언제든 가변이 될 수 있기 때문이다.
    
    단점으로는 메모리 낭비를 유발할 수 있다.
    
    - Garbage Collect커스텀을 통해 개선할 수 있다.
- 불변 만드는 방법
    
    원시 타입에서의 불변
    
    - 원시 타입은 값을 그대로 외부로 내보내도 불변임을 보장한다.
    - setter를 통해서는 객체 내부에서의 원시 타입을 불변을 막을수 없다.
    - setter를 생성하지 않고, finla을 붙여줘 생성자만을 통해서 설정되도록하면 불변을 보장할 수 있다. 혹은 특정 메시지를 통해서만 원시 타입이 변경되도록 하면된다.
    
    참조 타입에서의 불변
    
    - 객체는 기본적으로 참조 값을 통해 접근하기에, 불변성을 보장하기 어렵다
    - final + 방어적 복사를 통해 참조 타입을 불변으로 만들 수 있다.
    - 컬렉션을 불변으로 만들기 위해서는, 해당 컬렉션의 요소도 불변으로 만들어줘야한다.
- 자바에서 null을 안전하게 다루는 방법은?
    
    null의 정의
    
    - null은 값이 할당되지 않은 변수
    - 모든 참조 유형이 될 수 있는 특수 리터럴
    
    null의 문제점
    
    - null은 쉽게 Null Point Exception를 발생시킬 수 있다.
    - null을 반환할 수 있는 메서드는 클라이언트로 하여금 혼란을 초래할 수 있다.
        - 클라이언트 입장에서 null이 반환되는 메서드인지 아닌지 항상 확인해줘야 한다.
    
    null을 안전하게 다루는 방법
    
    - Assertion(단정문) 사용
    - Objects 사용 (isNull, nonNull, requireNonNull,…)
    - Optional
    
    추천하는 null 방지 도구
    
    - Optional
    - JSR305
    - JSR308(@NonNull, @Nullable)
- Optional 사용시 주의할 점
    
    Optional은 최대 1개 원소를 가지는 특별한 Stream이다.
    
    isPresent()를 사용하지 않는다. → orElse, orElseGet등을 사용
    
    - isPresent()를 호출하여 null인지 확인하고 다른 로직을 가져가는 경우 이 경우 굳이 Optional로 감쌀 필요가 없다.
    - 차라리 그냥 null인지 확인하는 로직을 넣는 것이 더 좋다. 대신 orElse, orElseGet 등등 사용하자.
    
    orElse(new …) 대신 orElseGet(() → new …)를 사용하자
    
    - orElse(new …)는 무조건 실행된다. 만약 새로운 객체를 생성하거나 새로운 연산을 수행하는 경우에는 orElseGet(() → new …)를 사용하자 이는 Optional에 값이 없을때만 실행된다.
    - Optional은 필드로 사용하면 안된다. 반환 값으로만 사용하자
    - Optional은 비싸다. 비어있는 컬렉션은 반환할 때는 Optional을 감싸지 말고, 빈 컬렉션을 반환
- java의 non-static와 static의 차이
    - non-static은 특정 객체의 대한 상태(동적 변수 혹은 인스턴스 변수)를 의미하고, static은 여러 객체가 공유하는 상태(정적 변수 혹은 클래스 변수)를 의미한다.
    - non-static은 객체가 생성되고 할당되며, 해당 객체의 상태를 나타내며, static은 객체가 생성되지 않아도 할당되며, 모든 객체에서 사용 가능하다.
    - non-static 메서드에서는 static 변수와 메서드에 모두 접근 가능하지만, static 메서드에서는 non-static 변수와 메서드에 접근하지 못한다 → 아직 생성되지 않았기 때문에)
    - 생명주기가 다르다. non-static은 인스턴스와 생명주기를 같이하며, static은 프로그램과 생명주기를 같이한다.
    - 쉽게 얘기하면, non-static은 인스턴스(객체)에 속하고, static은 클래스 자체에 속한다.
- Enum을 사용하는 이유
    
    Enum이란?
    
    - 서로 연관된 상수들의 집합
    - 클래스를 이용한 상수
        - 각각의 상수들은 모두 인스턴스화된 싱글톤 객체 이다.
        - 각각의 상수들은 서로 다른 데이터를 의미한다.
        - 같은 집합의 상수들은 같은 데이터 타입을 가지므로 서로 다른 집합의 상수끼리 비교 연산은 컴파일 시에 막을 수 있다.
    - 사용하는 이유
        - 상수를 객체처럼 사용할수 있다.
        - 서로 연관된 상수들끼리 집합으로 묶고, 서로 다른 집합의 상수끼리 비교 연산을 컴파일 타임에 막을 수 있기때문
- 오버로딩과 오버라이딩의 차이
    
    오버로딩 : 재구성
    
    - 한 클래스 내에 같은 이름의 메서드를 여러개 정의한느것 단, 기존 메서드와 매개변수의 개수 또는 타입이 달라야 한다.
    - 새로운 메서드를 정의하는것
    
    오버라이딩 : 재정의
    
    - 인터페이스 혹은 상위 클래스의 메서드를 재정의
    - 기존 메서드를 재정의하는것
- Stream이란? 장점과 특징
    
    Stream이란?
    
    - Stream은 선언형 방식으로 컬렉션 데이터를 조작하는 API
        - 선언형 방식 : 내부 반복 → Stream을 이용한 내부 반복
        - 명령형 방식 : 외부 반복 → 기존의 반복문을 통한 외부 반복
    - 스트림은 ‘데이터의 흐름’이다. 배열 또는 컬렉션에 함수 여러개를 조합해서 원하는 결과를 필터링하고 가공된 결과를 얻을 수 있다.
        - DB의 쿼리와 같이 정형화된 처리 패턴을 적용 시킨것
        - 배열 혹은 컬렉션의 데이터를 쿼리(Stream와 동일하다고 봐도 무방) 하는것
- Stream에서 map과 flatmap의 차이는?
    - map은 단일 스트림 안에 요소를 원하는 특정 형태로 변환시켜주는 중간 연산 메서드
    - flatmap은 스트림의 형태(요소)가 배열이나 리스트일때 각 리스트의 모든 원소를 특정 형태로 변환하고 단일 원소 스트림으로 반환시켜주는 중간 연산 메서드
- 함수형 프로그래밍 개념과 특징
    
    함수형 프로그래밍
    
    - 함수를 값으로 바라보고 명령형이 아닌 선언형으로 프로그래밍하는 프로그래밍 방식을 말한다.
    
    명령형과 선언형
    
    - 명령형 프로그래밍
        - What보다는 How을 나타냄
        - 클래스에서 메서드를 정의하고, 필요할때 그 메서드를 호출하는 명령하여 동작
    - 선언형 프로그래밍
        - How보다는 What을 설명
        - 데이터가 입력으로 주어지고, 데이터가 처리되는 과정(흐름)을 정의하는 것으로 동작
    
    함수형 프로그래밍의 조건
    
    - 순수 함수
        - 부수효과가 없으며, 같은 입력이 주어지면 항상 같은 결과를 반환한다.
        - 멀티 스레드로부터 안전하다.
    - 고차 함수
        - 일급 함수의 특징을 만족해야한다.
        - 함수의 인자로 함수를 전달할 수 있다.
        - 함수의 리턴값으로 함수를 사용할 수 있다.
    - 익명 함수
        - 이름이 없는 함수. 자바에서의 익명 클래스 혹은 람다식
    - 합성 합수
        - 새로운 함수를 생성하거나 어떤 계산을 수행하기 위해 둘 이상의 함수를 결합하는 것이다.
        - 메서드 체이니
    
    함수형 프로그래밍의 특징
    
    - 불변성
        - 상태를 변경하지 않는것
        - 상태를 변경하게 되면, 부수효과가 생기게 되어 순수 함수의 조건을 만족하지 못한다.
    - 참조 투명성(순수 함수)
        - 프로그램 동작의 변경없이 관련 값을 대처할 수 있다면 표현식을 참조 상 투명하다고 한다.
        - 즉, 참조상 투명한 함수는 같은 입력이 주어지면 항상 같은 결과를 반환한다.
    - 일급 함수
        - 함수를 함수의 매개변수, 반환값, 자료구조로 사용할 수 있다.
    - 게으른 평가
        - 함수형 언어에서는 값이 필요한 시점에 평가된다.
    
    함수형 프로그래밍의 장점
    
    - 동시성에서 발생할 수 있는 부수효과를 없앨 수 있다.
    - 멅티 스레딩 환경에서 스레드 세이프를 보장하면서 안정적으로 병렬처리를 할 수 있다.
    - 높은 수준의 추상화를 지원한다. 개발자는 How 보다는 What에 집중할수 있다. (핵심 가치에 집중 가능)
    - 함수 단위의 코드 재사용이 수월하다.
    - 불변이기에 코드를 예측하기 쉽다.
- Lambda식이란?
    
    Lambda식이란
    
    - 람다식은 메서드를 하나의 ‘식'으로 표현한 것이다.
    - 메서드로 전달할 수 있는 익명 클래스 메서드를 단순화 한것
    - 한수형 인터페이스를 이용하여 람다식을 구현한다.
    
    Lambda는 함수형 프로그래밍의 특징은 모두 가지고 있다고 보면 된다.
    
    - 일급 객체의 역할을 수행할 수 있으며, 메서드의 매개변수로 전달될 수도 있다. 또한, 변수에 담거나, 메서드의 결과값으로 반환될 수도 있다.
    
    장점
    
    - 불필요한 코드를 줄여주고, 가독성을 높여준다,
    - 익명 클래스와는 다르게 클래스를 생성하지 않는다.
- 익명 클래스 vs 람다식
    
    둘의 차이점은 바이트 코드를 보면 쉽게 파악할 수 있다.
    
    익명 내부 클래스는 새로운 클래스를 생성하지만, 람다는 새로운 메서드를 생성하여 포함한다.
    
    - 익명 내부 클래스
        - `static` 중첩 클래스를 생성한다.
    - 람다식
        - 람다식은 `static`이든, 객체를 사용을 위한 `non-static`이든 클래스를 따로 생성하지 않고, 메서드를 생성한다.
    - `this`
        - 익명 내부 클래스의 `this` : 새로 생성된 클래스
            - 새로운 클래스를 만들기 때문에, 익명 내부 클래스에서의 `this`는 익명 클래스 자신을 가리킨다.
        - 람다식의 `this` : 람다식이 선언된 (포함하고 있는) 클래스
            - 람다식은 새로운 메서드로 볼 수 있으며, 메서드에서 `this`는 메서드를 가진 클래스를 의미한다.
            - 람다식에서는 `this`는 람다를 포함하고 클래스의 인스턴스이다.
    - 메서드의 개수
        - 익명 내부 클래스는 여러개의 메서드를 가질 수 있다.
        - 람다식은 `@FunctionalInterface`를 사용하므로, 하나 이상의 메서드를 가지면 컴파일 에러가 발생한다.
    - 람다도 일종의 클로저다
        - 클로저 : 함수 범위 밖의 자유변수를 참조할 수 있는 함수
        - 람다가 람다식 범위 밖에 변수에 접근하고자 한다면, 해당 변수는 `final`이어야 한다.
- == 과 equals()의 차이점은?
    
    == : 동일성
    
    - == 은 primitive면 값 비교, reference이면 주소 비교를 통해 boolean 값을 리턴한다.
    
    equlas() : 동등성
    
    - equals()는 Object 클래스에 정의된 메서드이며, 객체의 값을 비교하여 boolean 값을 리턴한다.
    - equals()와 hashCode()를 재정의함으로써 동등성을 구현한다.
    
    hashCode() : 재정의하지 않는다면
    
    - HashMap과 HashTable에서 key에 대한 중복 여부를 equals()와 hashCode()로 하기 때문에, 둘 다 재정의해줘야 한다.
    - hashCode()를 재정의할 땐, 해당 객체의 상태를 통해 해시값을 계산해야 한다.
- Checked Exception vs Unchecked Exception
    
    다른점
    
    - 컴파일때 예외처리 여부
    
    Checked Exception
    
    - 프로그래머가 별도의 예외처러를 하지 않으면 컴파일 단계에서 오류를 발생시키는 예외
    - 비관적인 예외처리 기법이라 불린다.
    - SQLException, IOException
    
    UncheckedException
    
    - 프로그래머가 별도의 예외처리를 하지 않아도 컴파일 단계에서 오류를 발생시키지 않는 예외
    - 낙관적인 예외처리 기법이라 불린다.
    - Null Point Exception, RuntimeException
- Checked Exception을 지양하는 이유는?
    
    자칫 잘못하면 한 메서드를 사용하는 모든 메서드가 무책임하게 throws로 예외를 던지는 문제가 발생한다.
    
    OCP(개방 폐쇄의 원칙)를 위반하게 도리수도 있다.→ 결합도가 높아진다.
    
    - 특정 클래스에 의존하는 다른 클래스들로 예외 시그니처가 전달되고, 그로 인해 발생하는 결합도가 유지보드성에 악영향을 끼친다.
    - 또한, 모든 상위 메서드들이 최하위 메서드의 예외 시그니처를 알아야 하므로 캡슐화가 깨진다.
    
    예외를 throw 한 메서드와 depth가 3만 멀어져도 이 예외의 발생 근원지를 추측하기가 어려워진다.
    
    - 어디서 진짜 예외가 발생했는지 찾기가 힘들다는 것
    
    물론 반대 의견도 있다. 바로 엘리강트 오브젝트
    
    - 각 클래스, 메서드의 시그니처가 아주 명확해야 한다는 의견이다.
    - 즉, 예외 가능성이 있는 메서드가 Unchecked Exception을 사용하는 것은 클라이언트를 속인다는것!
    - 하지만, 개인적으로 Unchecked를 사용하고, 문서화를 하는것이 좋아보인다.
    
    Checked Exception 지양한 예시
    
    - SQLException → DataAccessException
- 업캐스팅과 다운 캐스팅
- 정적 바인딩 vs 동적 바인딩
- Collection vs Collections
- 접근 제어자
- 직렬화 / 역직렬화 차이
- 깊은 복사와 얕은 복사